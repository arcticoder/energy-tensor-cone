/-
  FiniteToyModel.lean

  This file is the first *proved* step toward the conjecture.

  We model a finite family of AQEI constraints as linear inequalities on a
  finite-dimensional coefficient space E ≃ ℝ^n:

    C := {x | ∀ i, 0 ≤ (L i) x}

  For any fixed finite family of continuous linear functionals L_i, this is an
  intersection of closed half-spaces, hence closed and convex.

  We then specialize to the nonnegative orthant (coordinate inequalities),
  and show it has a nontrivial extreme ray (the i-th basis vector).
-/

import Mathlib

set_option autoImplicit false

namespace FiniteToyModel

open scoped BigOperators

/-- A minimal “extreme ray” predicate, matching the repo's informal notion. -/
def IsExtremeRay {E : Type} [AddCommMonoid E] [Module ℝ E]
    (C : Set E) (r : E) : Prop :=
  r ≠ 0 ∧ r ∈ C ∧
    ∀ x y,
      x ∈ C → y ∈ C → r = x + y →
        (∃ (α : ℝ), 0 ≤ α ∧ x = α • r) ∧ (∃ (μ : ℝ), 0 ≤ μ ∧ y = μ • r)

/-- The admissible set determined by a finite family of inequalities `0 ≤ L i x`. -/
def Admissible {E : Type} [TopologicalSpace E] [AddCommMonoid E] [Module ℝ E]
    (m : Type) [Fintype m] (L : m → E →L[ℝ] ℝ) : Set E :=
  {x | ∀ i : m, 0 ≤ (L i) x}

section General

variable {E : Type} [TopologicalSpace E] [AddCommMonoid E] [Module ℝ E]
variable {m : Type} [Fintype m] (L : m → E →L[ℝ] ℝ)

theorem admissible_isClosed : IsClosed (Admissible (E := E) m L) := by
  classical
  -- Each constraint set is the preimage of the closed ray `Ici 0`.
  have hset : Admissible (E := E) m L = ⋂ i : m, (fun x : E => (L i) x) ⁻¹' (Set.Ici (0 : ℝ)) := by
    ext x
    simp [Admissible, Set.preimage, Set.mem_iInter]
  -- Finite intersection of closed sets.
  rw [hset]
  apply isClosed_iInter
  intro i
  exact isClosed_Ici.preimage (L i).continuous

end General

section Orthant

/-- Coefficient space `ℝ^n` as functions `Fin n → ℝ`. -/
abbrev E (n : Nat) := Fin n → ℝ

/-- Nonnegative orthant in `ℝ^n`. -/
def NonnegOrthant (n : Nat) : Set (E n) := {x | ∀ i, 0 ≤ x i}

theorem nonnegOrthant_isClosed (n : Nat) : IsClosed (NonnegOrthant n) := by
  classical
  -- Present as an intersection of preimages under the continuous evaluation maps.
  have hset : NonnegOrthant n = ⋂ i : Fin n, (fun x : E n => x i) ⁻¹' (Set.Ici (0 : ℝ)) := by
    ext x
    simp [NonnegOrthant, Set.mem_iInter]
  -- Each `fun x => x i` is continuous.
  simpa [hset] using (isClosed_iInter (fun i : Fin n => (isClosed_Ici.preimage (continuous_apply i))))

theorem nonnegOrthant_convex (n : Nat) : Convex ℝ (NonnegOrthant n) := by
  intro x hx y hy a b ha hb hab
  -- Pointwise inequality.
  intro i
  have hx' := hx i
  have hy' := hy i
  -- `smul_add` etc are pointwise on Pi types.
  -- `simp [NonnegOrthant]` rewrites membership into componentwise inequalities.
  -- We then use `mul_nonneg` and `add_nonneg`.
  simpa [NonnegOrthant, Pi.add_apply, Pi.smul_apply, hab, add_comm, add_left_comm, add_assoc] using
    add_nonneg (mul_nonneg ha hx') (mul_nonneg hb hy')

theorem nonnegOrthant_closed_under_add (n : Nat) :
    ∀ x y, x ∈ NonnegOrthant n → y ∈ NonnegOrthant n → x + y ∈ NonnegOrthant n := by
  intro x y hx hy i
  exact add_nonneg (hx i) (hy i)

theorem nonnegOrthant_closed_under_smul (n : Nat) :
    ∀ (x : E n) (a : ℝ), x ∈ NonnegOrthant n → 0 ≤ a → a • x ∈ NonnegOrthant n := by
  intro x a hx ha i
  simpa [Pi.smul_apply] using mul_nonneg ha (hx i)

/-- Standard basis vector `e i` in `ℝ^n`. -/
def basisVec {n : Nat} (i : Fin n) : E n := fun j => if j = i then 1 else 0

theorem basisVec_mem_orthant {n : Nat} (i : Fin n) : basisVec (n := n) i ∈ NonnegOrthant n := by
  intro j
  by_cases h : j = i
  · simp [basisVec, h]
  · simp [basisVec, h]

theorem basisVec_ne_zero {n : Nat} (i : Fin n) : basisVec (n := n) i ≠ (0 : E n) := by
  intro h
  have := congrArg (fun f => f i) h
  simp [basisVec] at this

/-- A concrete nontrivial extreme ray: the ray generated by a coordinate axis. -/
theorem basisVec_isExtremeRay {n : Nat} (i : Fin n) : IsExtremeRay (NonnegOrthant n) (basisVec (n := n) i) := by
  refine ⟨basisVec_ne_zero (i := i), basisVec_mem_orthant (i := i), ?_⟩
  intro x y hx hy hxy
  -- For any j ≠ i, we have (basisVec i) j = 0 = x j + y j, hence x j = 0 and y j = 0.
  have hx0 : ∀ j : Fin n, j ≠ i → x j = 0 := by
    intro j hj
    have hbasis : (basisVec (n := n) i) j = 0 := by simp [basisVec, hj]
    have hsum : x j + y j = 0 := by
      -- basisVec is 0 off-diagonal, and basisVec = x + y
      calc (x + y) j = (basisVec (n := n) i) j := by rw [← hxy]
           _ = 0 := hbasis
    -- x j ≤ 0 since x j ≤ x j + y j = 0, and x j ≥ 0.
    have xle0 : x j ≤ 0 := by
      calc
        x j ≤ x j + y j := le_add_of_nonneg_right (hy j)
        _ = 0 := hsum
    exact le_antisymm xle0 (hx j)

  have hy0 : ∀ j : Fin n, j ≠ i → y j = 0 := by
    intro j hj
    have hbasis : (basisVec (n := n) i) j = 0 := by simp [basisVec, hj]
    have hsum : x j + y j = 0 := by
      -- basisVec is 0 off-diagonal, and basisVec = x + y
      calc (x + y) j = (basisVec (n := n) i) j := by rw [← hxy]
           _ = 0 := hbasis
    have yle0 : y j ≤ 0 := by
      calc
        y j ≤ x j + y j := le_add_of_nonneg_left (hx j)
        _ = 0 := hsum
    exact le_antisymm yle0 (hy j)

  -- Let λ = x i, μ = y i.
  refine ⟨⟨x i, hx i, ?_⟩, ⟨y i, hy i, ?_⟩⟩
  · -- x = (x i) • basisVec i
    ext j
    by_cases hj : j = i
    · subst hj
      simp [basisVec, Pi.smul_apply]
    · have : x j = 0 := hx0 j hj
      simp [basisVec, hj, this, Pi.smul_apply]
  · -- y = (y i) • basisVec i
    ext j
    by_cases hj : j = i
    · subst hj
      simp [basisVec, Pi.smul_apply]
    · have : y j = 0 := hy0 j hj
      simp [basisVec, hj, this, Pi.smul_apply]

end Orthant

end FiniteToyModel

-- Completeness checks
#print axioms FiniteToyModel.admissible_isClosed
#print axioms FiniteToyModel.nonnegOrthant_isClosed
#print axioms FiniteToyModel.nonnegOrthant_convex
#print axioms FiniteToyModel.basisVec_isExtremeRay
#print axioms FiniteToyModel.Admissible

