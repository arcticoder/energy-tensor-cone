import json
from pathlib import Path


def fourier_inverse_square_benchmark(g_samples: list[float], dt: float) -> float:
    """Toy Fourier-space benchmark integral with an inverse-square weight.

    This is *not* a full implementation of a model-specific QEI bound, which
    requires additional state/field data. It exists to support numerical
    sanity-checks and figure generation that compare proxy bounds against a
    representative inverse-frequency weighting.

    Returns a nonnegative scalar.
    """

    if dt <= 0:
        raise ValueError("dt must be positive")
    if not g_samples:
        raise ValueError("g_samples must be non-empty")

    try:
        import numpy as np
    except Exception as e:  # pragma: no cover
        raise RuntimeError("numpy is required for Fourier benchmark") from e

    g = np.asarray(g_samples, dtype=float)
    n = int(g.shape[0])
    freqs = np.fft.fftfreq(n, d=float(dt))
    g_hat = np.fft.fft(g)

    eps = 1e-12
    weight = 1.0 / (freqs * freqs + eps)
    # Discrete sum as a rough stand-in for a continuum integral.
    val = (1.0 / (2.0 * np.pi)) * float(np.sum(np.abs(g_hat) ** 2 * weight))
    return max(0.0, val)


def _as_lean_string(s: str) -> str:
    return '"' + s.replace('\\', '\\\\').replace('"', '\\"') + '"'


def _as_lean_float(x) -> str:
    # Lean's Float literals accept standard decimal / scientific notation.
    if isinstance(x, (int, float)):
        return repr(float(x))
    return repr(float(x))


def generate_lean_candidates(results_dir: Path, out_file: Path, top_k: int = 5) -> None:
    """Convert Mathematica JSON output into a Lean file with candidate data.

    This is intentionally data-only; semantics are added later when a finite basis model
    of StressEnergy is formalized.
    """
    results_dir = Path(results_dir)
    out_file = Path(out_file)

    top_path = results_dir / "top_near_misses.json"
    if not top_path.exists():
        raise FileNotFoundError(f"Missing {top_path}")

    data = json.loads(top_path.read_text())
    data = list(data)[:top_k]

    out_file.parent.mkdir(parents=True, exist_ok=True)

    lines: list[str] = []
    lines.append("import Std")
    lines.append("")
    lines.append("/- Auto-generated from Mathematica results. -/")
    lines.append("/- (Candidate list removed as unused) -/")
    lines.append("")

    # Previous structure Candidate and topNearMisses removed.
    pass

    out_file.write_text("\n".join(lines) + "\n")

    print(f"Wrote {out_file}")


def analyze_results(results_dir: Path = None) -> None:
    """Analyze and report on JSON results from Mathematica search.
    
    Loads violations.json for concrete validation statistics.
    """
    if results_dir is None:
        results_dir = Path(__file__).parent.parent / "mathematica" / "results"
    
    results_dir = Path(results_dir)
    
    # Load and report violations for validation
    violations_path = results_dir / "violations.json"
    if violations_path.exists():
        violations = json.loads(violations_path.read_text())
        print(f"Concrete violations found: {len(violations)}")
        if violations:
            scores = [v.get("score", 0.0) for v in violations]
            print(f"  Violation score range: [{min(scores):.6f}, {max(scores):.6f}]")
    else:
        print("No violations.json found (not generated by current LP-based search)")
    
    # Report on other file existence
    for fname in ["summary.json", "near_misses.json", "top_near_misses.json", "vertex.json"]:
        fpath = results_dir / fname
        if fpath.exists():
            print(f"  Found: {fname}")


if __name__ == "__main__":
    analyze_results()
